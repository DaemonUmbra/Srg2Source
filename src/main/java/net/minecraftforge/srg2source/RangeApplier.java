package net.minecraftforge.srg2source;

import java.io.File;
import java.io.IOException;
import java.io.OutputStream;
import java.nio.charset.Charset;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;

import joptsimple.OptionParser;
import joptsimple.OptionSet;
import net.minecraftforge.srg2source.rangeapplier.RangeMap;
import net.minecraftforge.srg2source.rangeapplier.RangeMap.RangeEntry;
import net.minecraftforge.srg2source.rangeapplier.RenameMap;
import net.minecraftforge.srg2source.rangeapplier.SrgContainer;
import net.minecraftforge.srg2source.util.ExceptorFile;
import net.minecraftforge.srg2source.util.LocalVarFile;
import net.minecraftforge.srg2source.util.Util;
import net.minecraftforge.srg2source.util.io.FolderSupplier;
import net.minecraftforge.srg2source.util.io.InputSupplier;
import net.minecraftforge.srg2source.util.io.OutputSupplier;

import com.google.common.io.ByteStreams;

public class RangeApplier
{

    @SuppressWarnings("unchecked")
    public static void main(String[] args) throws IOException
    {
        // configure parser
        OptionParser parser = new OptionParser();
        {
            parser.acceptsAll(Arrays.asList("h", "help")).isForHelp();
            parser.accepts("srcRoot", "Source root directory to rename").withRequiredArg().ofType(File.class).isRequired(); // var=srcRoot
            parser.accepts("srcRangeMap", "Source range map generated by srg2source").withRequiredArg().ofType(File.class).isRequired(); // var=srcRangeMap
            parser.accepts("srgFiles", "Symbol map file(s), separated by ' '").withRequiredArg().ofType(File.class).isRequired(); // var=srgFiles
            parser.accepts("git", "Command to invoke git"); // var=git default="git"
            parser.accepts("lvRangeMap", "Original source range map generated by srg2source, for renaming local variables"); // var=lvRangeMap)  # TODO: csv instead?
            parser.accepts("mcpConfDir", "MCP configuration directory, for renaming parameters").withRequiredArg().ofType(File.class); // var=mcpConfDir
            parser.accepts("excFiles", "Parameter map file(s), separated by ' '").withRequiredArg().ofType(File.class); // var=excFiles
            parser.accepts("no-rewriteFiles", "Disable rewriting files with new symbol mappings"); //, var="rewriteFiles", default=True
            parser.accepts("no-renameFiles", "Disable renaming files with new filenames"); // var="renameFiles", default=True
            //parser.accepts("no-dumpRenameMap", "Disable dumping symbol rename map before renaming"); // var="dumpRenameMap", default=True
            parser.accepts("dumpRangeMap", "Enable dumping the ordered range map and quit"); // var=dumpRangeMap, default=False
            parser.accepts("outDir", "The output folder for editted classes.").withRequiredArg().ofType(File.class); // default null
        }

        OptionSet options = parser.parse(args);

        if (options.has("help"))
        {
            parser.printHelpOn(System.out);
            System.exit(0);
        }

        //options.valuesOf("srgFiles");
        FolderSupplier srcRoot = new FolderSupplier((File) options.valueOf("srcRoot"));
        boolean rewriteFiles = !options.has("no-rewriteFiles");
        boolean renameFiles = !options.has("no-renameFiles");
        //boolean dumpRenameMap = !options.has("no-dumpRenameMap");
        boolean dumpRangeMap = options.has("dumpRangeMap");
        
        // output supplier..
        OutputSupplier outDir = (OutputSupplier) srcRoot;
        if (options.has("outDir"))
            outDir = new FolderSupplier((File) options.valueOf("outDir"));
            

        // read range map, spit, and return

        if (dumpRangeMap)
        {
            RangeMap ranges = new RangeMap().read((File) options.valueOf("srcRangeMap"));
            for (String key : ranges.keySet())
            {
                for (RangeEntry info : ranges.get(key))
                {
                    System.out.println(info);
                }
            }
            
            // y u annoy me eclipse!?!?!?
            srcRoot.close();
            outDir.close();
            
            return;
        }

        // get Srg files.  they are required
        SrgContainer srgs = new SrgContainer().readSrgs((List<File>) options.valuesOf("srgFiles"));

        // read Srgs into map
        RenameMap map = new RenameMap();
        map.readSrg(srgs);

        // read parameter remaps
        if (options.has("mcpConfDir") && options.hasArgument("mcpConfDir"))
        {
            File conf = (File) options.valueOf("mcpConfDir");
            ExceptorFile primary, secondary = null;
            primary = new ExceptorFile();
            if (new File(conf, "joined.exc").exists())
                primary.read(new File(conf, "joined.exc"));
            else
                primary.read(new File(conf, "packaged.exc"));

            if (options.has("excFiles") && options.hasArgument("excFiles"))
                secondary = new ExceptorFile().read((List<File>) options.valuesOf("excFiles"));

            map.readParamMap(srgs, primary, secondary);
        }

        // read local varaible map
        if (options.has("lvRangeMap") && options.hasArgument("lvRangeMap"))
        {
            LocalVarFile lv = new LocalVarFile().read((File) options.valueOf("lvRangeMap"));
            map.readLocalVariableMap(lv, srgs);
        }

        // read range map
        System.out.println("Reading range map...");
        RangeMap ranges = new RangeMap().read((File) options.valueOf("srcRangeMap"));

        System.out.println("Processing files...");
        for (String key : ranges.keySet())
        {
            if (key.startsWith("jline"))
                continue;
//            else if (key.startsWith("net/minecraft/"))
//            {
//                processJavaSourceFile(srcRoot, outDir, key, ranges.get(key), map.maps, map.imports, false, rewriteFiles, renameFiles);
//            }
            else
            {
                //processJavaSourceFile(srcRoot, outDir, key, ranges.get(key), map.getQualified(), new HashMap<String, String>(), false, rewriteFiles, renameFiles);
                processJavaSourceFile(srcRoot, outDir, key, ranges.get(key), map.maps, map.imports, false, rewriteFiles, renameFiles);
            }
        }

        srcRoot.close();
        outDir.close();
        System.out.println("FINISHED!");
    }

    /**
     * Rename symbols in source code
     * @throws IOException
     */
    private static void processJavaSourceFile(InputSupplier inSup, OutputSupplier outSup, String fileName, Collection<RangeEntry> rangeList, Map<String, String> renameMap, Map<String, String> importMap, boolean shouldAnnotate, boolean rewrite, boolean rename) throws IOException
    {
        String data = new String(ByteStreams.toByteArray(inSup.getInput(fileName)), Charset.forName("UTF-8"));

        if (data.contains("\r"))
        {
            // BlockJukebox == the only file with CRLF line endings in NMS.. and.. IntelliJ IDEA treats offsets 
            // as line endings being one character, whether LF or CR+LF. So remove the extraneous character or
            // offsets will be all off :.
            //  Yes I have a pull request on this: https://github.com/Bukkit/CraftBukkit/pull/985
            System.out.println("Warning: " + fileName + " has CRLF line endings; consider switching to LF");
            data = data.replace("\r", "");
        }
        
        StringBuilder outData = new StringBuilder();
        outData.append(data);

        Set<String> importsToAdd = new TreeSet<String>();
        int shift = 0;

        // Existing package/class name (with package, internal) derived from filename
        String oldTopLevelClassFullName = Util.getTopLevelClassForFilename(fileName);
        String oldTopLevelClassPackage = Util.splitPackageName(oldTopLevelClassFullName);
        String oldTopLevelClassName = Util.splitBaseName(oldTopLevelClassFullName);

        // New package/class name through mapping
        String newTopLevelClassPackage = Util.sourceName2Internal(renameMap.get("package " + oldTopLevelClassPackage));
        String newTopLevelClassName = renameMap.get("class " + oldTopLevelClassFullName);
        if (newTopLevelClassPackage != null && newTopLevelClassName == null)
            throw new RuntimeException("filename " + fileName + " found package " + oldTopLevelClassPackage + "->" + newTopLevelClassPackage + " but no class map for " + newTopLevelClassName);
        if (newTopLevelClassPackage == null && newTopLevelClassName != null)
            throw new RuntimeException("filename " + fileName + " found class map " + oldTopLevelClassName + "->" + newTopLevelClassName + " but no package map for " + oldTopLevelClassPackage);

        // start,end,expectedOldText,key
        for (RangeEntry info : rangeList)
        {
            int end = info.end;
            String expectedOldText = info.expectedOldText;
            if (renameMap.containsKey(info.key) && renameMap.get(info.key).isEmpty())
            {
                // Replacing a symbol with no text = removing a symbol
                if (!info.key.startsWith("package "))
                    throw new RuntimeException("unable to remove non-package symbol " + info.key);

                // Remove that pesky extra period after qualified package names
                end++;
                expectedOldText += ".";
            }

            String oldName = outData.substring(info.start + shift, end + shift);

            if (!oldName.equals(expectedOldText))
                throw new RuntimeException("Rename sanity check failed: expected '" + expectedOldText + "' at [" + info.start + "," + end + "] (shifted " + shift + " to [" + (shift + info.start) + "," + (shift + end) + "]) in " + fileName + ", but found '" + oldName + "'\nRegenerate symbol map on latest sources or start with fresh source and try again");

            String newName = getNewName(info.key, oldName, renameMap, shouldAnnotate);
            if (newName == null)
            {
                if (info.key.split(" ")[1].contains("net/minecraft"))
                    System.out.println("No rename for " + info.key);
                continue;
            }

            System.out.println("Rename " + info.key + "[" + (info.start + shift) + "," + (end + shift) + "]" + "::" + oldName + "->" + newName);

            if (importMap.containsKey(info.key))
            {
                // This rename requires adding an import, if it crosses packages
                String importPackage = Util.splitPackageName(Util.sourceName2Internal(importMap.get(info.key)));
                if (!importPackage.equals(newTopLevelClassPackage))
                    importsToAdd.add(importMap.get(info.key));
            }
            // Rename algorithm: 
            // 1. textually replace text at specified range with new text
            // 2. shift future ranges by difference in text length
            //data = data.substring(0, info.start + shift) + newName + data.substring(end + shift);
            outData.replace(info.start + shift, end + shift, newName);
            shift += (newName.length() - oldName.length());
        }
        
        if (fileName.endsWith("Transformer.java"))
            System.out.println("lala");

        // Lastly, update imports - this == separate from symbol range manipulation above
        String outString = updateImports(outData, importsToAdd, importMap);

        if (rewrite)
        {
            System.out.println("Writing " + fileName);
            OutputStream outStream = outSup.getOutput(fileName);
            outStream.write(outString.getBytes(Charset.forName("UTF-8")));
            outStream.close();
        }

        if (rename)
        {
            if (newTopLevelClassPackage != null) // rename if package changed
            {
                String newFileName = (newTopLevelClassPackage + "/" + newTopLevelClassName + ".java").replace('\\', '/');

                System.out.println("Rename file " + fileName + " -> " + newFileName);

                if (!fileName.equals(newFileName))
                {
                    OutputStream outStream = outSup.getOutput(newFileName);
                    outStream.write(outString.getBytes(Charset.forName("UTF-8")));
                    outStream.close();
                }
            }
        }
    }

    /**
     * Add new import statements to source
     */
    private static String updateImports(StringBuilder data, Set<String> newImports, Map<String, String> importMap)
    {
        //String[] lines = data.split("\n");
        
        int lastIndex = 0;
        int nextIndex = data.indexOf("\n");
        // Parse the existing imports and find out where to add ours
        // This doesn't use Psi.. but the syntax is easy enough to parse here
        boolean addedNewImports = false;
        boolean sawImports = false;

        String line;
        while (nextIndex > -1)
        {
            line = data.substring(lastIndex,  nextIndex);
            
            while (line.startsWith("\n"))
            {
                lastIndex++;
                line = data.substring(lastIndex,  nextIndex);
            }
            
            if (line.startsWith("import "))
            {
                sawImports = true;

                if (line.startsWith("import net.minecraft."))
                {
                    // If no import map, *remove* NMS imports (OBC rewritten with fully-qualified names)
                    if (importMap.isEmpty())
                    {
                     // next line.
                        lastIndex = nextIndex + 1; // +1 to skip the \n at the end of the line there
                        nextIndex = data.indexOf("\n", lastIndex+1); // another +1 because otherwise it would just return lastIndex
                        continue;
                    }

                    // Rewrite NMS imports
                    String oldClass = line.replace("import ", "").replace(";", "");
                    System.out.println("Import: " + oldClass);

                    String newClass = oldClass;
                    if (oldClass.equals("net.minecraft.server.*"))
                    {
                     // next line.
                        lastIndex = nextIndex + 1; // +1 to skip the \n at the end of the line there
                        nextIndex = data.indexOf("\n", lastIndex+1); // another +1 because otherwise it would just return lastIndex
                        
                        // wildcard NMS imports (CraftWorld, CraftEntity, CraftPlayer).. bad idea
                        continue;
                    }
                    else if (importMap.containsKey("class " + Util.sourceName2Internal(oldClass)))
                        newClass = importMap.get("class " + Util.sourceName2Internal(oldClass));

                    if (newImports.contains(newClass))  // if not already added
                    {
                        // otherwise remove from the file... it will be added again later.
                        data.delete(lastIndex, nextIndex + 1); // the newLine too
                        nextIndex = data.indexOf("\n", lastIndex); // get from here to the end of the line.
                        continue;
                    }
                    else
                    {
                        int change = "import ".length();
                        data.replace(lastIndex, nextIndex, "import ");
                        data.insert(lastIndex + change, newClass);
                        change += newClass.length();
                        data.insert(lastIndex + change, ";");
                        nextIndex = lastIndex + change + 1; // +1 for the semicolon
                    }
                }
            }
            else if (sawImports && !addedNewImports)
            {
                // Add our new imports right after the last import
                System.out.println("Adding " + newImports.size() + " imports");
                
                CharSequence sub = data.subSequence(lastIndex, data.length()); // grab the rest of the string.
                data.setLength(lastIndex); // cut off the build there
                
                for (String imp : newImports)
                    data.append("import ").append(imp).append(";\n");
                
                int change = data.length() - lastIndex; // get changed size
                lastIndex = data.length(); // reset the end to the actual end..
                nextIndex += change; // shift nextIndex accordingly..
                
                data.append(sub); // add on the rest if the string again
                
                addedNewImports = true;
            }
            
            // next line.
            lastIndex = nextIndex + 1; // +1 to skip the \n at the end of the line there
            nextIndex = data.indexOf("\n", lastIndex+1); // another +1 because otherwise it would just return lastIndex
        }

        // got through the whole file without seeing or adding any imports???
        if (!addedNewImports)
        {
            // insert imports after the second line.
            int index = data.indexOf("\n") + 1;
            index = data.indexOf("\n", index) + 1; // search again from the second point, for 2 lines. +1 for after the \n
            
            CharSequence sub = data.subSequence(index, data.length()); // grab the rest of the string.
            data.setLength(index); // cut off the build there
            
            for (String imp : newImports)
                data.append("import ").append(imp).append(";\n");
            
            data.append(sub); // add on the rest if the string again
        }
        
        String newData = data.toString();

        // Warning: ugly hack ahead
        // The symbol range map extractor is supposed to emit package reference ranges, which we can 
        // update with the correct new package names. However, it has a bug where the package ranges
        // are not always emitted on fully-qualified names. For example: (net.minecraft.server.X)Y - a
        // cast - will fail to recognize the net.minecraft.server package, so it won't be processed by us.
        // This leads to some qualified names in the original source to becoming "overqualified", that is,
        // net.minecraft.server.net.minecraft.X; the NMS class is replaced with its fully-qualified name
        // (in non-NMS source, where we want it to always be fully-qualified): original package name isn't replaced.
        // Occurs in OBC source which uses fully-qualified NMS names already, and NMS source which (unnecessarily)
        // uses fully-qualified NMS names, too. Attempted to fix this problem for longer than I should.. 
        // maybe someone smarter can figure it out -- but until then, in the interest of expediency, I present 
        // this ugly workaround, replacing the overqualified names after-the-fact.
        // Fortunately, this pattern is easy enough to reliably detect and replace textually!
        newData = newData.replace("net.minecraft.server.net", "net");  // OBC overqualified symbols
        newData = newData.replace("net.minecraft.server.Block", "Block"); // NMS overqualified symbols
        // ..and qualified inner classes, only one.... last ugly hack, I promise :P
        newData = newData.replace("net.minecraft.block.BlockSapling/*was:BlockSapling*/.net.minecraft.block.BlockSapling.TreeGenerator", "net.minecraft.block.BlockSapling.TreeGenerator");
        newData = newData.replace("net.minecraft.block.BlockSapling.net.minecraft.block.BlockSapling.TreeGenerator", "net.minecraft.block.BlockSapling.TreeGenerator");
        
        return newData;
    }

    private static String getNewName(String key, String oldName, Map<String, String> renameMap, boolean shouldAnnotate)
    {
        String newName;
        if (!renameMap.containsKey(key))
        {
            String constructorClassName = getConstructor(key);
            if (constructorClassName != null)
            {
                // Constructors are not in the method map (from .srg, and can't be derived
                // exclusively from the class map since we don't know all the parameters).. so we
                // have to synthesize a rename from the class map here. Ugh..but, it works.
                System.out.println("FOUND CONSTR " + key + " " + constructorClassName);
                if (renameMap.containsKey("class " + constructorClassName))
                    // Rename constructor to new class name
                    newName = Util.splitBaseName(renameMap.get("class " + constructorClassName));
                else
                    return null;
            }
            else
                // Not renaming this
                return null;
        }
        else
            newName = renameMap.get(key);

        if (shouldAnnotate)
            newName += "/* was " + oldName + "*/";

        return newName;
    }

    /**
     * Check whether a unique identifier method key is a constructor, if so return full class name for remapping, else null
     */
    private static String getConstructor(String key)
    {
        String[] tokens = key.split(" ", 3);  // TODO: switch to non-conflicting separator..types can have spaces :(
        if (!tokens[0].equals("method"))
            return null;
        System.out.println(Arrays.toString(tokens));
        //kind, fullMethodName, methodSig = tokens
        if (tokens[2].charAt(tokens[2].length() - 1) != 'V') // constructors marked with 'V' return type signature in ApplySrg2Source and MCP
            return null;
        String fullClassName = Util.splitPackageName(tokens[1]);
        String methodName = Util.splitBaseName(tokens[1]);

        String className = Util.splitBaseName(fullClassName);

        if (className.equals(methodName)) // constructor has same name as class
            return fullClassName;
        else
            return null;
    }
}
